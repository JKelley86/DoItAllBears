<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Satisfying Arena</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body{
  margin:0;
  background:#0e0e11;
  overflow:hidden;
  font-family:sans-serif;
}

canvas{
  display:block;
}
</style>
</head>

<body>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize",resize);

const center = () => ({
  x: canvas.width/2,
  y: canvas.height/2
});

const ARENA_RADIUS = Math.min(canvas.width,canvas.height)*0.4;

class Ball{
  constructor(){
    const angle = Math.random()*Math.PI*2;
    const r = ARENA_RADIUS*0.5*Math.random();

    const c = center();
    this.x = c.x + Math.cos(angle)*r;
    this.y = c.y + Math.sin(angle)*r;

    this.vx = (Math.random()-0.5)*4;
    this.vy = (Math.random()-0.5)*4;

    this.radius = 8;
    this.lines = [];
    this.color = `hsl(${Math.random()*360},80%,60%)`;
    this.alive = true;
  }

  update(){
    if(!this.alive) return;

    this.x += this.vx;
    this.y += this.vy;

    const c = center();
    const dx = this.x - c.x;
    const dy = this.y - c.y;
    const dist = Math.sqrt(dx*dx+dy*dy);

    // hit circle wall
    if(dist > ARENA_RADIUS - this.radius){
      const angle = Math.atan2(dy,dx);

      // reflect velocity
      const nx = Math.cos(angle);
      const ny = Math.sin(angle);
      const dot = this.vx*nx + this.vy*ny;
      this.vx -= 2*dot*nx;
      this.vy -= 2*dot*ny;

      // clamp inside
      this.x = c.x + nx*(ARENA_RADIUS - this.radius);
      this.y = c.y + ny*(ARENA_RADIUS - this.radius);

      // attach line to wall
      this.lines.push({
        x: this.x,
        y: this.y
      });
    }
  }

  draw(){
    if(!this.alive) return;

    ctx.strokeStyle = this.color;
    ctx.lineWidth = 1;

    // draw lines
    this.lines.forEach(l=>{
      ctx.beginPath();
      ctx.moveTo(this.x,this.y);
      ctx.lineTo(l.x,l.y);
      ctx.stroke();
    });

    // ball
    ctx.beginPath();
    ctx.fillStyle = this.color;
    ctx.arc(this.x,this.y,this.radius,0,Math.PI*2);
    ctx.fill();
  }
}

let balls = [];

function spawn(){
  balls=[];
  for(let i=0;i<5;i++) balls.push(new Ball());
}
spawn();

function breakLines(){
  balls.forEach(ball=>{
    if(!ball.alive) return;

    ball.lines = ball.lines.filter(line=>{
      let intact=true;

      balls.forEach(other=>{
        if(other===ball || !other.alive) return;

        // distance from other ball to line segment
        const dx = line.x - ball.x;
        const dy = line.y - ball.y;

        const t = ((other.x-ball.x)*dx + (other.y-ball.y)*dy)/(dx*dx+dy*dy);
        const clamped = Math.max(0,Math.min(1,t));

        const px = ball.x + dx*clamped;
        const py = ball.y + dy*clamped;

        const dist = Math.hypot(other.x-px, other.y-py);

        if(dist < other.radius){
          intact=false;
        }
      });

      return intact;
    });

    if(ball.lines.length===0){
      ball.alive=false;
    }
  });
}

function drawArena(){
  const c = center();

  ctx.strokeStyle="#2a2a35";
  ctx.lineWidth=3;
  ctx.beginPath();
  ctx.arc(c.x,c.y,ARENA_RADIUS,0,Math.PI*2);
  ctx.stroke();
}

function loop(){
  ctx.fillStyle="rgba(14,14,17,0.25)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  drawArena();

  balls.forEach(b=>{
    b.update();
    b.draw();
  });

  breakLines();

  const alive = balls.filter(b=>b.alive);
  if(alive.length<=1){
    setTimeout(spawn,1500);
  }

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
