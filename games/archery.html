<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Archery Practice</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: linear-gradient(to top, #87CEEB, #E0F7FA);
    height: 100%;
    width: 100%;
  }
  #gameCanvas {
    position: absolute;
    left: 0;
    top: 0;
    background: #a6e4a6;
  }
  #rotateMsg {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: sans-serif;
    font-size: 1.5em;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 15px 25px;
    border-radius: 10px;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="rotateMsg">ðŸ”„ Please rotate your device to landscape</div>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const rotateMsg = document.getElementById("rotateMsg");

function resizeCanvas() {
  const landscape = window.innerWidth > window.innerHeight;
  rotateMsg.style.display = landscape ? "none" : "block";
  if (!landscape) return;
  const scale = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * scale;
  canvas.height = window.innerHeight * scale;
  ctx.scale(scale, scale);
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const Engine = Matter.Engine,
      World = Matter.World,
      Bodies = Matter.Bodies,
      Body = Matter.Body,
      Vector = Matter.Vector;

const engine = Engine.create();
const world = engine.world;

const ground = Bodies.rectangle(window.innerWidth / 2, window.innerHeight - 20, window.innerWidth, 40, { isStatic: true });
World.add(world, ground);

const target = Bodies.circle(window.innerWidth - 150, window.innerHeight - 200, 40, { isStatic: true });
World.add(world, target);

let arrows = [];
let pulling = false;
let bowPos = { x: 150, y: window.innerHeight - 150 };
let pullStart = { x: 0, y: 0 };
let pullEnd = { x: 0, y: 0 };

function startPull(x, y) {
  pulling = true;
  pullStart = { x, y };
}
function movePull(x, y) {
  if (pulling) pullEnd = { x, y };
}
function releasePull() {
  if (!pulling) return;
  pulling = false;
  const dx = pullStart.x - pullEnd.x;
  const dy = pullStart.y - pullEnd.y;
  const power = Math.min(Math.sqrt(dx * dx + dy * dy) / 5, 30);
  const angle = Math.atan2(dy, dx);
  const arrow = Bodies.rectangle(bowPos.x, bowPos.y, 60, 5, { density: 0.002, frictionAir: 0.01 });
  Body.setAngle(arrow, angle);
  Body.setVelocity(arrow, { x: -Math.cos(angle) * power, y: -Math.sin(angle) * power });
  arrows.push(arrow);
  World.add(world, arrow);
}

canvas.addEventListener("mousedown", e => startPull(e.offsetX, e.offsetY));
canvas.addEventListener("mousemove", e => movePull(e.offsetX, e.offsetY));
canvas.addEventListener("mouseup", releasePull);

canvas.addEventListener("touchstart", e => {
  const t = e.touches[0];
  startPull(t.clientX, t.clientY);
});
canvas.addEventListener("touchmove", e => {
  const t = e.touches[0];
  movePull(t.clientX, t.clientY);
});
canvas.addEventListener("touchend", releasePull);

function drawTarget() {
  ctx.beginPath();
  const x = target.position.x, y = target.position.y;
  const rings = ["white", "black", "blue", "red", "yellow"];
  for (let i = rings.length - 1; i >= 0; i--) {
    ctx.fillStyle = rings[i];
    ctx.beginPath();
    ctx.arc(x, y, 10 + i * 10, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawArrows() {
  ctx.fillStyle = "brown";
  arrows.forEach(a => {
    ctx.save();
    ctx.translate(a.position.x, a.position.y);
    ctx.rotate(a.angle);
    ctx.fillRect(-30, -2, 60, 4);
    ctx.restore();
  });
}

function drawBow() {
  ctx.beginPath();
  ctx.strokeStyle = "black";
  ctx.lineWidth = 6;
  ctx.arc(bowPos.x, bowPos.y, 40, Math.PI / 2, -Math.PI / 2, true);
  ctx.stroke();
  if (pulling) {
    ctx.beginPath();
    ctx.moveTo(bowPos.x, bowPos.y - 40);
    ctx.lineTo(pullEnd.x, pullEnd.y);
    ctx.lineTo(bowPos.x, bowPos.y + 40);
    ctx.strokeStyle = "gray";
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

function loop() {
  if (window.innerWidth < window.innerHeight) {
    requestAnimationFrame(loop);
    return;
  }
  Engine.update(engine);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawTarget();
  drawArrows();
  drawBow();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
